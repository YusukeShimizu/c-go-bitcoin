package ecc

import (
	"math/big"

	"golang.org/x/xerrors"
)

// 2**256 - 2**32 - 977
func genPrime() *big.Int {
	prime := big.NewInt(0)
	prime.Exp(big.NewInt(2), big.NewInt(256), nil)
	fraction := big.NewInt(0)
	fraction.Exp(big.NewInt(2), big.NewInt(32), nil)
	fraction.Add(fraction, big.NewInt(977))
	return prime.Sub(prime, fraction)
}

func NewS256Field(number *big.Int) (*fieldElement, error) {
	prime := genPrime()
	if number.Cmp(prime) >= 0 {
		return nil, xerrors.New("number is larger than prime")
	}
	return &fieldElement{number: number, prime: prime}, nil
}

type s256Point struct {
	*point
	n *big.Int
}

func NewS256Point(bx, by *big.Int) (*s256Point, error) {
	prime := genPrime()
	x, err := NewFieldElement(bx, prime)
	if err != nil {
		return nil, err
	}
	y, err := NewFieldElement(by, prime)
	if err != nil {
		return nil, err
	}
	a, err := NewFieldElement(big.NewInt(0), prime)
	if err != nil {
		return nil, err
	}
	b, err := NewFieldElement(big.NewInt(7), prime)
	if err != nil {
		return nil, err
	}
	sp, err := NewPoint(x, y, a, b)
	if err != nil {
		return nil, err
	}
	hexN := "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
	// We specify the order of the group generated by G, n.s
	n, ok := new(big.Int).SetString(hexN, 0)
	if !ok {
		return nil, xerrors.Errorf("coundn't generate the order of the group generated by G from hex:,%s", hexN)
	}
	return &s256Point{sp, n}, nil
}

func (s s256Point) sRMul(coefficient *big.Int) error {
	return s.FastRMul(coefficient.Mod(coefficient, s.n))
}
